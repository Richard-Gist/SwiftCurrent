@Tutorial(time: 30) {
    @Intro(title: "Core") {
        Core text
    }
    
    @Section(title: "What is a Workflow?") {
        @ContentAndMedia {
            In this section you'll learn what a workflow is under the covers. You'll be walked through LinkedList, _WorkflowItem, FlowRepresentableMetadata, AnyWorkflow.PassedArgs, and Workflow.
        }
        
        @Steps {
            @Step {
                Start with LinkedList, all workflows end up being doubly linked lists so this data type is a great starting point. You'll notice that it partially mimics Swift sequence types, but is not a struct. This is somewhat deliberate, we rely on inheritance logic and did not design this type so that anyone could use LinkedList outside of SwiftCurrent.
                
                @Code(name: "LinkedList.swift", file: "LinkedList.swift", reset: true)
            }
            
            @Step {
                LinkedList has nodes, they are value types that hold onto references for the previous and next items. They also have methods for traversing the list, starting at the current node.
                
                @Code(name: "LinkedListNode.swift", file: "LinkedListNode.swift", reset: true)
            }
            
            @Step {
                As mentioned already, a Workflow is a doubly linked list. Each node in a workflow is a `_WorkflowItem`. These nodes hold onto 2 important things. The first is the `FlowRepresentableMetadata` for the node. We will explore that in the next step. The next is just an instance of the `AnyFlowRepresentable` if one was loaded.
                
                @Code(name: "_WorkflowItem.swift", file: "_WorkflowItem.swift", reset: true)
            }
            
            @Step {
                This metadata is the primary means by which items in a workflow are created. It holds onto a factory to create `AnyFlowRepresentable` references from passed in arguments. It also holds onto peripheral items like the persistence and launch style of a given `FlowRepresentable`.
                
                @Code(name: "FlowRepresentableMetadata.swift", file: "FlowRepresentableMetadata.swift", reset: true)
            }
            
            @Step {
                In the previous example it's noticeable that the factory and persistence require an `AnyWorkflow.PassedArgs` type. This type is almost identical to `Optional` but was specifically created to remove ambiguity. If we had used `Optional` it would've been unclear to consumers if an item in a workflow as passing `nil` as an argument, or if there were no arguments passed.
                
                @Code(name: "PassedArgs.swift", file: "PassedArgs.swift", reset: true)
            }
            
            @Step {
                Let's finally take a look at Workflow. In particular, notice that there are "actions" that Workflow handles. Launching, which involves loading the first `FlowRepresentable` that should load given the launch arguments. Proceeding, which is similar, but not identical to launching. Finally, backing up, which is a matter of finding the last loaded `FlowRepresentable`.
                
                Workflow knows how to handle persistence and can allow a `FlowRepresentable` that has a `shouldLoad` returning false to still mutate data.
                
                @Code(name: "Workflow.swift", file: "Workflow.swift", reset: true)
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            What is the difference between a `FlowRepresentable` that has a `WorkflowInput` of `Any?` and a `FlowRepresentable` that has a `WorkflowInput` of `AnyWorkflow.PassedArgs`.

            @Choice(isCorrect: false) {
                `Any?` means any kind of data, including no data can be passed. `AnyWorkflow.PassedArgs` is equivalent, it's just not an optional.

                @Justification(reaction: "Try again!") {
                    Remember, `AnyWorkflow.PassedArgs` was deliberately built because an Optional wasn't enough to differentiate between "No data" and "Data, but it's nil".
                }
            }

            @Choice(isCorrect: true) {
                `Any?` means any kind of data, including nil can be passed to this `FlowRepresentable`. However, *something* must be passed forward. `AnyWorkflow.PassedArgs` means that some data (which can be nil) or no data at all (`AnyWorkflow.PassedArgs.none`) can be passed.

                @Justification(reaction: "That's right!") {
                    `AnyWorkflow.PassedArgs` is the only way to have a `FlowRepresentable` truly be able to interpret any situation, data being passed or no data being passed.
                }
            }

            @Choice(isCorrect: false) {
                `Any?` is broad enough to also include `AnyWorkflow.PassedArgs`. It's just a Swift way of saying "it doesn't matter what gets passed". `AnyWorkflow.PassedArgs` is more narrow, it means only certain `FlowRepresentable` types can pass data to this `FlowRepresentable.`
                
                @Justification(reaction: "Try again!") {
                    Remember, `AnyWorkflow.PassedArgs` was deliberately built because an Optional wasn't enough to differentiate between "No data" and "Data, but it's nil". While convention may lead you to believe that `Any?` is more broad than `AnyWorkflow.PassedArgs` that's not true in this context.
                }
            }
        }  
    }
}
